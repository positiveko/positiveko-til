# 2022.01

## 1/18 코드에서 나는 악취
## 3.1 기이한 이름

코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 이름이다. 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경써서 이름을 지어야 한다.

하지만 이름 짓기는 프로그래밍에서 가장 어려운 두가지 중 하나다. 그 때문에 우리가 가장 많이 사용하는 리팩터링도 `함수 선언 바꾸기`, `변수 이름 바꾸기`, `필드 이름 바꾸기` 처럼 이름을 바꾸는 리팩터링들이다.

이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다. 코드가 중복되면 각각을 볼때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.

한 클래스에서 두 메서드가 똑같은 표현식을 사용하는 경우가 있다. 이럴 때는 `함수 추출하기` 를 써서 양쪽 모두 추출한 메서드를 호출하게 바꾸면 된다.

코드가 비슷한데 완전히 똑같지는 않다면, 먼저 `문장 슬라이드하기` 로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다. 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 `메서드 올리기`를 적용해 부모로 옮긴다.

## 3.3 긴 함수

선생님들의 오랜 경험에 비추어보았을 때, 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수들로 구성이 되어 있다.

## 3.4 긴 매개변수 목록

함수가 배개변수로 받는 것들이 많아진다면 그 자체로 이해하기 어려워질 수 있다.
 
## 1/17 새로운 지식 습득하기

```
기술을 습득하고 수련하는 것은 사람에게 천성은 아니며 그것 자체가 수련해야 할 또 하나의 기술이다. - 워드 커닝햄
```

새로운 지식을 습득하는 것이 힘들다면 계속 부딪혀서 내성이 생기도록 체득하면 된다.

## 1/16 함수 추출하기

코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.
코드를 독립적인 함수로 묶을 때의 기준은 **목적과 구현을 분리**하는 방식으로 한다.
코드를 보고 어떤 기능을 하는지 파악하는 데 한참이 걸린다면 그 부분을 함수로 추출하고 '무슨 일'을 하는지 이름을 지어둔다.
이렇게 하면 나중에 코드를 읽을 때 목적이 눈에 들어오고 본문 코드(구체적으로 수행하는 일)에는 더 이상 신경 쓰지 않아도 된다.

### 절차

1. 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다. ('어떻게'가 아닌 '**무엇을**' 하는지가 드러나야 한다.)
2. 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
3. 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
4. 변수를 다 처리했다면 컴파일한다.
5. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다.(즉, 추출한 함수로 일을 위임한다)
6. 테스트한다.
7. 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다.

## 1/14 useEffect와 useLayoutEffect

```jsx
useEffect(() => {
  // do side effects
  return () => /* cleanup */
}, [dependency, array]);

useLayoutEffect(() => {
  // do side effects
  return () => /* cleanup */
}, [dependency, array]);
```

useEffect는 화면에 렌더링이 그려진 후에 비동기적으로 실행된다.
그래서 1) 렌더링 변경이 일어나면 (상태 변경, 부모의 리렌더링)

2. 리액트는 컴포넌트를 렌더링하고
3. 스크린은 시각적으로 업데이트 되는데
4. 그럼 useEffect가 실행된다.

반면에 useLayoutEffect는 렌더링 후이지만 화면에 업데이트 되기 전에 동기적으로 실행된다.'

1. 렌더링 변경이 일어나면 (상태 변경, 부모의 리렌더링)
2. 리액트는 컴포넌트를 렌더링하고
3. useLayoutEffect가 실행되고서 리액트는 이것이 끝나길 기다린다.
4. 스크린이 시각적으로 업데이트 된다.

useLayoutEffect는 리액트가 DOM을 업데이트하기 전에 약간의 추가 작업을 수행하는 방법.
그래서 만약 화면에 불필요한 깜빡거림(준비되지 않은 데이터로 한번 렌더링이 되고, 최종 데이터로 렌더링 되는 등..)이 발생할 경우 useLayoutEffect가 힌트가 될 수 있음.

아래 코드 예제에서 렌더링을 비교해볼 수 있다.
[useLayoutEffect](https://codesandbox.io/s/uselayouteffect-no-flash-ylyyg)와 [useEffect](https://codesandbox.io/s/useeffect-flash-on-render-yluoi)

[참고](https://daveceddia.com/useeffect-vs-uselayouteffect/)

## 1/13 attribute와 property 차이

attribute는 HTML 문서에서 사용되고, property는 DOM 객체에서 사용된다. HTML이 파싱되어서 DOM 객체를 생성하기 때문에 attribute는 property가 된다고 할 수 있다.
둘의 차이는 타입과 이름에 있다.
property는 모든 타입이 될 수 있는 반면에 attribute는 문자열만 허용된다.
또 property의 이름은 대소문자를 구별하지만 attribute는 구분하지 않는다.
HTML 문서는 대소문자를 구분하지 않고, DOM 객체는 자바스크립트 객체와 같은 성격을 갖기 때문이다.

## 1/12 Symbol & Enum

#### Symbol

Symbol은 중복되지 않는 상수 값을 생성하고 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하고 외부에 노출할 필요가 없는 프로퍼티를 은닉하기 위해, 즉 하위 호환성을 보장하기 위해 ES6부터 도입되었다.

심벌은 변경 불가능한 원시 타입의 값이다. 심벌은 다른값과 중복되지 않는 유일무이한 값이다. 따라서 주로 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다. (cf. 프로퍼티 키로 사용 가능한 값: 빈 문자열을 포함한 모든 문자열 또는 심벌 값)

```js
// Symbol 함수를 호출해서 생성한다.
const newSymbol = Symbol();
console.log(typeof newSymbol); // 'symbol'
// 심벌 값은 외부로 노출되지 않는다.
console.log(newSymbol); // Symbol()
```

#### Enum

enum은 명명된 숫자 상수의 집합으로 열거형이라고 부른다. 자바스크립트는 enum을 지원하지 않지만 C, java, python 등 여러 언어와 자바스크립트의 상위 확장인 타입스크립트에서 지원한다.
자바스크립트에서 enum을 흉내내어 사용하려면 객체의 변경을 방지하기 위해 Object.freeze 메서드와 심벌 값을 사용한다.

```js
const Direction = Object.freeze({
  UP: Symbol('up'),
  DOWN: Symbol('down'),
  LEFT: Symbol('left'),
  RIGHT: Symbol('right'),
});
```

## 1/11 유사 배열 객체와 이터러블 객체

유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말함. 유사 배열 객체는 배열처럼 for 문으로 순회 가능.
이터러블 객체 iterable object는 Symbol.iterator 메서드를 구현하여 for...of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있는 객체를 말함.

ES6에서 제공하는 빌트인 이터러블은 Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), arguments, TypedArray 등이 있다.

## 1/10 타입스크립트의 효용

자세한 타입스크립트의 디자인 목표는 [여기](https://positiveko-til.vercel.app/til/js/typescript-design-goals.html)에 정리해놓았다. 본문은 [여기 TypeScript Design Goals](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)에서 확인 가능하다.

타입스크립트의 디자인 목표는 철옹성과 같은 안전한 타입 시스템을 도입해 자바스크립트에서 발생할 수 있는 모든 오류를 걷어내는 데 있는 게 아니라, 자바스크립트의 생산성을 보전하면서 오류가 될 수 있는 코드들을 걸러주는 거름망 같은 타입 시스템을 도입하는 데 있음. -
[링크](https://overcurried.com/%EC%95%88%EC%A0%84%ED%95%9C%20any%20%ED%83%80%EC%9E%85%20%EB%A7%8C%EB%93%A4%EA%B8%B0/)

## 1/9 객체 깊은 복사를 위한 재귀함수

객체의 깊은 복사의 방법에는 JSON 객체 메소드를 이용하거나 (`stringify()`, `parse()`) lodash의 `cloneDeep()` 메서드를 이용하는 방법이 있음.
하지만 JSON 객체 메소드는 문자열로 변환한 뒤에 객체로 다시 변환시키는 방식이므로 참조를 끊어내는 대신에 함수와 같은 값은 undefiend로 처리된다는 한계가 있다는 점 잊지 말고..
커스텀으로 재귀 함수를 작성해보면 아래와 같다.

```js
function deepCopy(obj) {
  if (obj === null || typeof obj !== 'object') return obj;

  const copy = {};
  for (let key in obj) {
    copy[key] = deepCopy(obj[key]);
  }
  return copy;
}

const obj = {
  a: 1,
  b: {
    c: 2,
  },
  func: function() {
    return this;
  },
};

const newObj = deepCopy(obj);
newObj.b.c = 3;

console.log(obj); // { a: 1, b: { c: 2 }, func: ƒ func() }
console.log(newObj); // { a: 1, b: { c: 3 }, func: ƒ func() }
```

## 1/8 렉시컬 스코프

렉시컬 스코프 한 줄 요약..
자바스크립트 엔진은 코드가 로드될 때 실행 컨텍스트를 생성하고 그 안에 선언된 변수, 함수를 실행 컨텍스트 최상단으로 호이스팅하는데 이러한 범주가 렉시컬 스코프..

## 1/4 Next.js Script 컴포넌트 업데이트

Next.js 버전 11(21.06) Script 컴포넌트 관련 정말 괜찮았던 업데이트..

- `beforeInteractive`: For critical scripts that need to be fetched and executed before the page is interactive, such as bot detection and consent management. These scripts are injected into the initial HTML from the server and run before self-bundled JavaScript is executed.
- `afterInteractive (default)`: For scripts that can fetch and execute after the page is interactive, such as tag managers and analytics. These scripts are injected on the client-side and will run after hydration.
- `lazyOnload`: For scripts that can wait to load during idle time, such as chat support and social media widgets.

기본적으로 페이지가 인터렉티브 가능한 상태일 때 script를 가져오는 게 디폴트라 TTI를 줄이는 방향으로 개선되었다. `beforeInteractive` 프로퍼티를 사용하면 인터렉티브 전에 미리 서버에서 자체 번들 JS가 실행되기 전에 초기 HTML과 같이 전달되는 프로퍼티가 있어서 사용자의 동의를 받고서 페이지를 띄워야하는 경우에 사용 가능하다.
아래처럼!

```html
<Script src={url} // consent mangagement strategy="beforeInteractive" onLoad={()
=> { // If loaded successfully, then you can load other scripts in sequence //
요거 괜찮은데..? }} />
```

그리고 기본 script 태그의 프로퍼티인 async와 defer가 어떻게 적용되는지 궁금했는데, 넥제 블로그 글 보고 궁금증 해결..

> We've also changed the default script loading experience in Next.js 11 **from preloading and async to defer.** Third-party scripts often compete with higher priority resources, such as CSS, fonts, and images. Maintaining the proper sequencing relative to these resources, as well as other scripts, is an undue burden on developers.

결국 기본 preloading하고 async하던 방식에서 defer로 변경되었으니 HTML 파싱도 막지 않을 거고 페이지 구성이 끝날 때까지 지연시키니까 FCP, LCP를 줄이는 데 도움이 될 것으로 보인다.

## 1/3 event.stopPropagation() 주의사항

### event.stopPropagation()

꼭 필요한 경우 아니면 쓰지 않기... 사람들이 페이지에서 어딜 클릭했는지와 같은 행동 패턴을 분석할 때 window 내에서 발생한 클릭 이벤트를 감지하게 되는데, 이런 분석 시스템의 코드는 클릭 이벤트를 캐치하기 위해 document.addEventListener('click', ...)을 사용함. 그런데 버블링을 막아놓으면 분석이 제대로 될 수 없겠지...? stopPropagation을 사용한 영역은 데드존이 되어버림. 따라서 커스텀 이벤트를 사용해서 문제 해결할 것

### 같은 코드일지라도 환경에 따라 퍼포먼스는 다룰 수 있다.

라이트하우스를 이용하면서도 느끼는 것이지만, 같은 코드일지라도 실행 환경(CPU, 브라우저 환경, OS 성능, browser extensions...)에 따라 성능이 천지차이인 경우를 보았다.

forloop이 forEach나 map과 같은 메서드보다 계산 시간이 빠르다는 결과가 Android나 다른 브라우저에서는 다르게 나온다는 포스팅을 보니, 어쩌면 코드 문법(계산 시간이 빠른 메서드를 사용하는 등)을 수정하는 단순한 방법만으로는 성능 최적화에서 사실상 무의미한 것이라는 생각이 든다. 구조적인 측면을 더 파고들거나, 비동기 코드를 개선해서 enormouse network payload를 줄이는 면이 더 효과적인 방법이 아닐까라는 생각.

## 1/2 parameter vs. argument

### parameter vs. argument

```js
const a = 1;
const foo = function(b) {
  // parameter, formal parameter, 매개변수, 형식 매개변수
};

foo(a); // arguments, actual parameter, 인자, 실인자
```
