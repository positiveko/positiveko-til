# 2022.02

## 2/5 브라우저 처리 단계에 따른 성능 개선

페이지를 떠나는 단계에서 브라우저는 메모리 해제 작업을 실행한다. 그러나 브라우저에 따라 메모리 해제를 담당하는 가비지 컬렉션 기능이 제대로 동작하지 않아 페이지가 느려질 수 있다. 따라서 페이지 이동 단계에서 일어나는 성능 문제를 개선하기 위해서는 필요 없는 변수나 객체를 삭제하고, 이벤트를 해제해서 메모리를 관리해야 한다.

브라우저에는 여러 처리 과정이 있지만 무엇보다 네트워크 통신 단계(DNS, TCP, Request, Response)에 들어가는 비용이 가장 크다. 네트워크 통신 단계에 들어가는 비용을 줄여서 성능을 높이는 방법에는 여러가지가 있다.

- 브라우저가 허용하는 호스트 별 동시 연결 개수를 활용해서 데이터와 파일을 동시에 받는 방법
- 쿠키의 크기를 줄여 요청 헤더의 크기를 줄이기
- 스타일시트 파일과 자바스크립트 파일을 gzip으로 압축해 전송받는 파일의 크기를 줄이는 방법
- 이미 다운로드한 리소스를 캐시에 저장해서 다시 사용하는 방법

브라우저 처리 단계는 서버에서 받은 HTML과 이미지, 스타일시트를 조합해서 사용자가 실제로 보는 화면을 만드는 단계다. 이 단계에서 onload 이벤트보다 DOMContentLoaded 이벤트로 DOM을 조작하는 시점을 조절하면 웹페이지의 응답 속도를 더 빠르게 할 수 있다.

## 2/4 structuredClone()으로 깊은 복사하기
[1/19 TIL](https://positiveko-til.vercel.app/til/2022/202201.html#_1-9-%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6-%E1%84%80%E1%85%B5%E1%87%81%E1%84%8B%E1%85%B3%E1%86%AB-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE)에서 객체의 깊은 복사를 구현하는 재귀 함수를 작성했었다. 이 방법 말고는 lodash의 cloneDeep()이 만능인줄 알았더니..
[structuredClone()](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) 메서드가 존재했다. 
아직 ECMAScript 명세에는 포함되지 않은 메서드이지만, 아래의 브라우저 환경에서 사용 가능(or 하게 될 예정)하다.
- Chrome 98
- Safari 137 (Technology Preview Release)
- Firefox 94
- Node.js 17.0
- Deno 1.14

```js
// value와 circular reference가 있는 객체를 작성한다.
const original = { name: "MDN" };
original.itself = original;

// clone it
const clone = structuredClone(original);

console.assert(clone !== original); // 같은 주솟값을 가지지 않으므로 다르다.
console.assert(clone.name === "MDN"); // 같은 값을 갖는다
console.assert(clone.itself === clone); // 순환 참조는 보전된다
```

하지만 몇몇 빌트인 객체들은 복사하지 못한다고 한다.
[여기](https://2ality.com/2022/01/structured-clone.html)서 확인해볼 수 있다. 

## 2/3 BOM, DOM

![BOM-DOM](https://programmer.help/images/blog/1047b9541148c907f5464f63223b0b48.jpg)
[출처](https://programmer.help/blogs/concepts-of-js-dom-and-bom-01.html)
### BOM(Browser Object Model)

브라우저 객체 모델은 브라우저 탭 또는 브라우저 창의 모델을 생성한다. 최상위 객체는 window 객체로 현재 브라우저 창 또는 탭을 표현하는 객체이다.

![BOM](https://miro.medium.com/proxy/0*Tk4fTMbOEOmGX_nU.png)
[출처](https://javascript.plainenglish.io/developer-interview-question-what-is-the-browser-object-model-dfbf43b9b367)
### DOM(Document Object Model)

문서 객체 모델은 현재 웹 페이지의 모델을 생성한다. 최상위 객체는 document 객체로 전체 문서를 포함한다.

## 2/2 Query Parameter & Path Variable

> resource를 가져오는 GET의 경우에는 PathVariables를 사용하고, 정렬이나 필터링을 하는 경우 QueryParam을 사용

### Query Parameter

```js
/users?id=123  // 아이디가 123인 사용자를 가져온다.
```

### Path Variable

```js
/users/123; // 아이디가 123인 사용자를 가져온다.
```

### 각각 언제 사용할까?

만약 어떤 resource를 식별하고 싶으면 PathVariable을 사용하고,
정렬이나 필터링을 한다면 Query Parameter를 사용하는 것이 좋음.

## 2/1 빌트인 객체, 호스트 객체

### 표준 빌트인 객체

- ECMAScript 사양에 정의된 객체이며 애플리케이션 전역의 공통적인 기능을 제공
- 자바스크립트 실행 환경과 관계 없이 언제나 사용 가능
- 별도의 선언 없이 전역 변수처럼 언제나 참조 가능

### 호스트 객체

- ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체
- 브라우저에서는 클라이언트 사이드 Web API(DOM, fetch, Canvas, SVG, Web Storage, Web Worker 등)를 호스트 객체로 제공
- Node.js 환경에서는 Node.js 고유의 API를 호스트로 제공

### 사용자 정의 객체

- 표준 빌트인 객체나 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체
