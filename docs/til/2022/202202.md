# 2022.02


## 2/8 DOM이 만들어지는 과정과 주의사항

브라우저에서 HTML과 같은 리소스를 전달받으면 브라우저 엔진이 이 리소스들을 렌더링하게 된다. 
HTML을 파싱하면서 `encoding` - `pre-parsing` - `tokenization` 하는 과정을 거쳐서 만들어지는 것이 DOM이다. 
파서는 토크나이저가 만든 토큰을 DOM 객체에 삽입하는 것인데, 이때 트리 데이터 구조로 생성되기 때문에 이 프로세스를 트리 구조화라고 한다.

HTML 파싱을 어렵게하는 요인 중에서 하나를 꼽자면 파싱이 진행되는 동안 script 태그 안의 자바스크립트 코드가 또 파싱해야 할 코드를 추가하는 경우다. 
자바스크립트의 DOM api 혹은 `document.write()`와 같은 코드가 실행되는 경우에는 HTML 파싱이 다시 실행된다는 것을 유의해야 한다.

이 파싱이 끝나면 `DOMContentLoaded` 이벤트가 실행되고, 웹 페이지의 모든 리소스들의 처리가 완료되면 `load()` 이벤트가 실행된다. 

### BOM (Browser Object Model)

브라우저 객체 모델은 브라우저 탭 또는 브라우저 창의 모델을 생성한다. 최상위 객체는 window 객체로 현재 브라우저 창 또는 탭을 표현하는 객체이다. 또한 이 객체의 자식 객체 들은 브라우저의 다른 기능들을 표현한다. 이 객체들은 Standard Built-in Objects가 구성된 후에 구성된다.
![bom](https://poiemaweb.com/img/BOM.png)

### DOM (Document Object Model)

문서 객체 모델은 현재 웹페이지의 모델을 생성한다. 최상위 객체는 document 객체로 전체 문서를 표현한다. 또한 이 객체의 자식 객체들은 문서의 다른 요소들을 표현한다. 이 객체들은 Standard Built-in Objects가 구성된 후에 구성된다.
![dom](https://poiemaweb.com/img/DOM.png)
[출처](https://poiemaweb.com/js-built-in-object)

## 2/6 브라우저가 웹 서버로 요청을 보내는 과정

1. 사용자는 주소창에 `positiveko-til.vercel.app`을 입력한다.
2. 브라우저는 해당 도메인을 HTTP 규약에 맞춰 데이터 패킷을 준비한다.
3. 준비된 패킷은 랜선 혹은 AP를 통해 해당 지역의 Tier 3 ISP까지 전달된다.
4. 이때 클라이언트는 빠른 응답을 위해 Cache Server에 캐싱해 놓은 결과가 있는지 먼저 확인하고, 캐시된 데이터가 있다면 더 진행하지 않고 이를 다시 클라이언트에 돌려준다.
5. ISP는 DNS를 겸하기도 하기 때문에 요청으로 들어온 `positiveko-til.vercel.app`의 IP 주소를 호가인한다.
6. 만약 해당 DNS에 정보가 없다면 다른 DNS 서버에 해당 도메인이 있는지 확인한다.
7. `positiveko-til.vercel.app`의 IP 주소가 `76.76.21.142`임을 브라우저가 알아낸다.
8. 브라우저는 해당 IP 주소로 HTTP Request를 보낸다.
9. 해당 도메인의 WAS는 요청을 받아서 필요 시 DB 작업을 처리한다.
10. 사용자 요청에 맞는 컨텐츠를 Status Code 등과 함께 HTTP Response로 돌려보낸다.
11. 다시 수많은 Router와 ISP를 거쳐 사용자의 브라우저에 컨텐츠가 도달한다.

## 2/5 브라우저 처리 단계에 따른 성능 개선

페이지를 떠나는 단계에서 브라우저는 메모리 해제 작업을 실행한다. 그러나 브라우저에 따라 메모리 해제를 담당하는 가비지 컬렉션 기능이 제대로 동작하지 않아 페이지가 느려질 수 있다. 따라서 페이지 이동 단계에서 일어나는 성능 문제를 개선하기 위해서는 필요 없는 변수나 객체를 삭제하고, 이벤트를 해제해서 메모리를 관리해야 한다.

브라우저에는 여러 처리 과정이 있지만 무엇보다 네트워크 통신 단계(DNS, TCP, Request, Response)에 들어가는 비용이 가장 크다. 네트워크 통신 단계에 들어가는 비용을 줄여서 성능을 높이는 방법에는 여러가지가 있다.

- 브라우저가 허용하는 호스트 별 동시 연결 개수를 활용해서 데이터와 파일을 동시에 받는 방법
- 쿠키의 크기를 줄여 요청 헤더의 크기를 줄이기
- 스타일시트 파일과 자바스크립트 파일을 gzip으로 압축해 전송받는 파일의 크기를 줄이는 방법
- 이미 다운로드한 리소스를 캐시에 저장해서 다시 사용하는 방법

브라우저 처리 단계는 서버에서 받은 HTML과 이미지, 스타일시트를 조합해서 사용자가 실제로 보는 화면을 만드는 단계다. 이 단계에서 onload 이벤트보다 DOMContentLoaded 이벤트로 DOM을 조작하는 시점을 조절하면 웹페이지의 응답 속도를 더 빠르게 할 수 있다.

## 2/4 structuredClone()으로 깊은 복사하기

[1/19 TIL](https://positiveko-til.vercel.app/til/2022/202201.html#_1-9-%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6-%E1%84%80%E1%85%B5%E1%87%81%E1%84%8B%E1%85%B3%E1%86%AB-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE)에서 객체의 깊은 복사를 구현하는 재귀 함수를 작성했었다. 이 방법 말고는 lodash의 cloneDeep()이 만능인줄 알았더니..
[structuredClone()](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) 메서드가 존재했다.
아직 ECMAScript 명세에는 포함되지 않은 메서드이지만, 아래의 브라우저 환경에서 사용 가능(or 하게 될 예정)하다.

- Chrome 98
- Safari 137 (Technology Preview Release)
- Firefox 94
- Node.js 17.0
- Deno 1.14

```js
// value와 circular reference가 있는 객체를 작성한다.
const original = { name: 'MDN' };
original.itself = original;

// clone it
const clone = structuredClone(original);

console.assert(clone !== original); // 같은 주솟값을 가지지 않으므로 다르다.
console.assert(clone.name === 'MDN'); // 같은 값을 갖는다
console.assert(clone.itself === clone); // 순환 참조는 보전된다
```

하지만 몇몇 빌트인 객체들은 복사하지 못한다고 한다.
[여기](https://2ality.com/2022/01/structured-clone.html)서 확인해볼 수 있다.

## 2/3 BOM, DOM

![BOM-DOM](https://programmer.help/images/blog/1047b9541148c907f5464f63223b0b48.jpg)
[출처](https://programmer.help/blogs/concepts-of-js-dom-and-bom-01.html)

### BOM(Browser Object Model)

브라우저 객체 모델은 브라우저 탭 또는 브라우저 창의 모델을 생성한다. 최상위 객체는 window 객체로 현재 브라우저 창 또는 탭을 표현하는 객체이다.

![BOM](https://miro.medium.com/proxy/0*Tk4fTMbOEOmGX_nU.png)
[출처](https://javascript.plainenglish.io/developer-interview-question-what-is-the-browser-object-model-dfbf43b9b367)

### DOM(Document Object Model)

문서 객체 모델은 현재 웹 페이지의 모델을 생성한다. 최상위 객체는 document 객체로 전체 문서를 포함한다.

## 2/2 Query Parameter & Path Variable

> resource를 가져오는 GET의 경우에는 PathVariables를 사용하고, 정렬이나 필터링을 하는 경우 QueryParam을 사용

### Query Parameter

```js
/users?id=123  // 아이디가 123인 사용자를 가져온다.
```

### Path Variable

```js
/users/123; // 아이디가 123인 사용자를 가져온다.
```

### 각각 언제 사용할까?

만약 어떤 resource를 식별하고 싶으면 PathVariable을 사용하고,
정렬이나 필터링을 한다면 Query Parameter를 사용하는 것이 좋음.

## 2/1 빌트인 객체, 호스트 객체

### 표준 빌트인 객체

- ECMAScript 사양에 정의된 객체이며 애플리케이션 전역의 공통적인 기능을 제공
- 자바스크립트 실행 환경과 관계 없이 언제나 사용 가능
- 별도의 선언 없이 전역 변수처럼 언제나 참조 가능

### 호스트 객체

- ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체
- 브라우저에서는 클라이언트 사이드 Web API(DOM, fetch, Canvas, SVG, Web Storage, Web Worker 등)를 호스트 객체로 제공
- Node.js 환경에서는 Node.js 고유의 API를 호스트로 제공

### 사용자 정의 객체

- 표준 빌트인 객체나 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체
